package com.leon.mandelbrot.mapreduce;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.BytesWritable;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.SequenceFile;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.input.SequenceFileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;
import org.monte.media.Format;
import org.monte.media.FormatKeys;
import org.monte.media.avi.AVIWriter;
import org.monte.media.math.Rational;

import javax.imageio.ImageIO;
import javax.imageio.stream.ImageOutputStream;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Random;

import static org.monte.media.FormatKeys.EncodingKey;
import static org.monte.media.FormatKeys.FrameRateKey;
import static org.monte.media.FormatKeys.MediaTypeKey;
import static org.monte.media.VideoFormatKeys.*;

/**
 * A map/reduce program that creates an animation of the mandelbrot set.
 * Given input parameters:
 *  - width: The width of the animated image in pixels
 *  - height: The height of the animated image in pixels
 *  - frames: The amount of the frames
 *  - firstScale: The multiplier for both x and y coordinate axis.
 *           A scale of 1 translates to the x interval being [-0.5,0.5].
 *  - firstTranslateX: Move the coordinate center to the right/left
 *  - firstTranslateY: Move the coordinate center to the top/bottom
 *  - lastScale, lastTranslateX, lastTranslateY
 *
 *
 * Mapper:
 *      The mapper's task is to calculate the colors of the given image frame.
 *      The mapper receives a list of key-value pairs to calculate
 *      in which the key is a frame number and the value is a row
 *      number of the specified key.
 *      The map then creates a list of key-value pairs with the key being
 *      the frame number and the value being the row number and an array of
 *      calculated colors.
 * Reducer:
 *      The reducer collects the created list of key-value pairs by key and
 *      then patches together the image for each frame, creating a two-dimensional
 *      array.
 *      The cleanup task then writes the frame into an image file.
 * Final Task:
 *      The final task is to take the iamges generated by the reducer and
 *      create a gif out of them.
 */
public class MandelbrotMapReduce extends Configured implements Tool{

    private static final String TMP_DIR_PREFIX = MandelbrotMapReduce.class.getSimpleName();

    /**
     * Run a map/reduce job and create an animation out of the generated images with given parameters.
     *
     * It will have the given width, height and amount of frames.
     * A scale of x means that the length of the x-Axis is 1/x.
     * The scale of the y-Axis is so that the image is not deformed.
     * The standard translation is so that the coordinate point of origin is in the center.
     * firstScale, firstTranslationX and firstTranslationY define the scale and translation of the first frame.
     * lastScale, lastTranslationX and lastTranslationY define the scale and translation of the last frame.
     *
     * @param width The animation width
     * @param height The animation height
     * @param frames The amount of frames
     * @param firstScale The scale of the first frame
     * @param firstTranslateX The x translation of the first frame
     * @param firstTranslateY The y translation of the first frame
     * @param lastScale The scale of the last frame
     * @param lastTranslateX The x translation of the last frame
     * @param lastTranslateY The y translation of the last frame
     * @param tmpDir A HDFS temporary directory to work in
     * @param conf The Hadoop configuration.
     * @throws IOException
     * @throws ClassNotFoundException
     * @throws InterruptedException
     */
    public static void createMandelbrotAnimation(
            int width,
            int height,
            int frames,
            double firstScale,
            double firstTranslateX,
            double firstTranslateY,
            double lastScale,
            double lastTranslateX,
            double lastTranslateY,
            Path tmpDir,
            Configuration conf
    ) throws IOException, ClassNotFoundException, InterruptedException {
        // set the configuration parameters
        conf.setInt(MandelbrotProperties.WIDTH, width);
        conf.setInt(MandelbrotProperties.HEIGHT, height);
        conf.setInt(MandelbrotProperties.FRAMES, frames);
        conf.setDouble(MandelbrotProperties.FIRST_SCALE, firstScale);
        conf.setDouble(MandelbrotProperties.FIRST_TRANSLATE_X, firstTranslateX);
        conf.setDouble(MandelbrotProperties.FIRST_TRANSLATE_Y, firstTranslateY);
        conf.setDouble(MandelbrotProperties.LAST_SCALE, lastScale);
        conf.setDouble(MandelbrotProperties.LAST_TRANSLATE_X, lastTranslateX);
        conf.setDouble(MandelbrotProperties.LAST_TRANSLATE_Y, lastTranslateY);
        // run the actual function (as the parameters are now saved in the configuration)
        createMandelbrotAnimation(tmpDir, conf);
    }

    /**
     * Run a map/reduce job and create an animation out of the generated images with the standard parameters.
     *
     * @param tmpDir A temporary directory to work in
     * @param conf The Hadoop configuration
     * @throws IOException
     * @throws ClassNotFoundException
     * @throws InterruptedException
     */
    public static void createMandelbrotAnimation(
            Path tmpDir,
            Configuration conf
    ) throws IOException, ClassNotFoundException, InterruptedException {

        // fetch some needed configuration parameters, or their default
        int width = conf.getInt(MandelbrotProperties.WIDTH, MandelbrotProperties.STANDARD_WIDTH);
        int height = conf.getInt(MandelbrotProperties.HEIGHT, MandelbrotProperties.STANDARD_HEIGHT);
        int frames = conf.getInt(MandelbrotProperties.FRAMES, MandelbrotProperties.STANDARD_FRAMES);

        Job job = Job.getInstance(conf);

        // Set up Job configuration
        job.setJobName(MandelbrotMapReduce.class.getSimpleName());
        job.setJarByClass(MandelbrotMapReduce.class);

        job.setInputFormatClass(SequenceFileInputFormat.class);

        job.setOutputKeyClass(IntWritable.class);
        job.setOutputValueClass(BytesWritable.class);
        job.setOutputFormatClass(SequenceFileOutputFormat.class);

        job.setMapperClass(MandelbrotMapper.class);

        job.setReducerClass(ImageReducer.class);
        job.setNumReduceTasks(frames);

        final Path inDir = new Path(tmpDir, "in");
        final Path outDir = new Path(tmpDir, "out");
        FileInputFormat.setInputPaths(job, inDir);
        FileOutputFormat.setOutputPath(job, outDir);
        
        final FileSystem fs = FileSystem.get(conf);
        if (fs.exists(tmpDir)) {
            throw new IOException("Tmp directory " + fs.makeQualified(tmpDir)
                + " already exists. Please remove it first.");   
        }
        if (!fs.mkdirs(inDir)) {
            throw new IOException("Cannot create input directory " + inDir);
        }
        
        try {
            // generate an input file for each map task
            for (int i = 0; i < frames; i++) {
                for (int j = 0; j < height; j++) {
                    final Path file = new Path(inDir, "part" + i + "_" + j);
                    final IntWritable frame = new IntWritable(i);
                    final IntWritable row = new IntWritable(j);
                    try (SequenceFile.Writer writer = SequenceFile.createWriter(
                            conf,
                            SequenceFile.Writer.file(file),
                            SequenceFile.Writer.keyClass(IntWritable.class),
                            SequenceFile.Writer.valueClass(IntWritable.class),
                            SequenceFile.Writer.compression(SequenceFile.CompressionType.NONE)
                    )) {
                        writer.append(frame, row);
                    }
                }
                System.out.println("Wrote input for Frame #" + i);
            }

            // start a map/reduce job
            System.out.println("Starting job");
            final long startTime = System.currentTimeMillis();
            job.waitForCompletion(true);
            final double duration = (System.currentTimeMillis() - startTime) / 1000.0;
            System.out.println("Job Finished in " + duration + " seconds");

            // read outputs and write them into a video
            AVIWriter out = null;
            Format format = new Format(
                    EncodingKey, ENCODING_AVI_PNG,
                    DepthKey, 24,
                    MediaTypeKey, FormatKeys.MediaType.VIDEO,
                    FrameRateKey, new Rational(30, 1),
                    WidthKey, width,
                    HeightKey, height
            );
            try {
                // set up video
                Path video = new Path(outDir, "mandelbrot.avi");
                OutputStream os = video.getFileSystem(conf).create(video);
                ImageOutputStream ios = ImageIO.createImageOutputStream(os);
                out = new AVIWriter(ios);
                out.addTrack(format);
                out.setPalette(0, ColorModel.getRGBdefault());

                for (int i = 0; i < frames; i++) {
                    Path inFile = new Path(outDir, "reduce-out_" + i);
                    IntWritable frame = new IntWritable();
                    BytesWritable image = new BytesWritable();
                    try (SequenceFile.Reader reader = new SequenceFile.Reader(
                            conf,
                            SequenceFile.Reader.file(inFile))) {
                        int readerIteration = 0;
                        while (reader.next(frame, image)) {
                            InputStream in = new ByteArrayInputStream(image.copyBytes());
                            BufferedImage img = ImageIO.read(in);
                            out.write(0, img, 1);
                            readerIteration++;
                            if (readerIteration > 1) {
                                System.err.println("Somehow more than one frame came up in one sequence file...");
                                System.err.println("File: " + inFile.getName());
                            }
                        }
                    }
                }
            } finally {
                if (out != null) {
                    out.close();
                }
            }
        } finally {
            fs.delete(tmpDir, true);
        }
    }

    @Override
    public int run(String[] args) throws Exception {
        // TODO: Take care of arguments
        if (args.length > 0) {
            ToolRunner.printGenericCommandUsage(System.err);
            return 2;
        }

        long now = System.currentTimeMillis();
        int rand = new Random().nextInt(Integer.MAX_VALUE);
        final Path tmpDir = new Path(TMP_DIR_PREFIX + "_" + now + "_" + rand);

        createMandelbrotAnimation(tmpDir, getConf());
        return 0;
    }

    public static void main(String[] args) throws Exception {
        System.exit(ToolRunner.run(null, new MandelbrotMapReduce(), args));
    }

}
